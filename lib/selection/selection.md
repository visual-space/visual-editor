# Selection (WIP)

## How Text Selection Works
`TextGesturesService` controls the selection of text after tapDown and tapUp events. Once the selection range is known it's then passed to the state store. Starting and updating the selection is triggered from the `TextGestures` widget and parsed by this service which in turn calls `TextSelectionService`. The `TextGestures` widget is used in the main `build()` method. It adds a gesture detector which interprets the various touchscreen signals into potential gestures. Once a gesture is detected in the callback executed, then the `controller.updateSelection()` is called which triggers the `refreshEditor()` which triggers a `build()` in main. Remember, the main `build()` contains the widgets generated by the `documentBlocsAndLines()`. These are a list of editable text lines and blocks. Once `build()` is triggered each `EditableTextLine` widget, then calls on the renderer object methods to update information. If the renderer callbacks notice that the selection is changed and within it's bounds then it triggers a `paint()` cycle. A new `paint()` cycle will "render" the selection rectangles vector data on top of the text.

## Selection Handles (WIP)
On mobile the copy paste actions are executed via the context menu. These are controlled by the `SelectionActionsController`. This controller is also in charge of rendering the options menu overlaid on top of the text.

Reading Material:

- [Flutter custom selection toolbar](https://ktuusj.medium.com/flutter-custom-selection-toolbar-3acbe7937dd3)

## Attaching Menus To Selections
We have separated the selection callback from the selection caching code because we have to wait for the build() to complete to extract the rectangles of a text selection. We want to use these rectangles to give total freedom to the client devs to decide how to place their attachments.

This means we now have 2 ways of customizing the selection menu:

1) When the selection callbacks have emitted we can use the rectangles data to place any attachment anywhere
   Recommended when you want to place atypical looking markers related to the lines of selected text
2) Standard flutter procedure using a custom TextSelectionControls
   Recommended when you want to display standard selection menu with custom buttons.

Therefore we decided to split the selection update cycle in two stages.

**Stage 1 - Updating Selection Extent**

- First, we collect the new selection extends (as it was done until now).
- We wait for the build() to complete to gain access to the latest selection rectangles from the editable line renderers.
- We cache the rectangles by lines information in the state store

**Stage 2 - Callback With Rectangles Data**

- Now that the build is complete and we have latest data, we call the selection callbacks that were defined in the original API, now including the rectangles data.

## Attaching Widgets To Text Selection Using Custom Controls (TBD)

## Attaching Widgets To Text Selection Using Markers

This is a general overview of setting up a selection menu or custom widgets when the text selection has changed. To view a complete sample go to the `SelectionMenuPage` and inspect the code. Looking at the demo code one can believe that the current API for managing selection menu is rather complex. However, our goal is not to provide a minified toolbars as the selection menu. Our goal is to provide an API that is versatile enough to be used for any menu, in any position triggered by any conditions you can think of. This gives maximum flexibility to implement any kind of UX interactions you might need for your particular app. Even the positioning logic was left open for the client developers to best decide what fits them best. If all you need is to setup a new button in the custom menu, then try using the custom controls option.

```dart
Widget build(BuildContext context) => Stack(
  children: [
    DemoPageScaffold(
      child: _controller != null
          ? _col(
              children: [
                _editor(),
                _toolbar(),
              ],
            )
          : Loading(),
    ),
    
    // Has to be a Positioned Widget (anything you need)
    if (_isQuickMenuVisible) _quickMenu(),
  ],
);
```

Init the editor controller with callbacks hooked to the selection events.

```dart
void _initEditorController(DocumentM document) {
   _controller = EditorController(
      document: document,
      onScroll: _updateQuickMenuPosition,

      // Hide menu while the selection is changing
      onSelectionChanged: (selection, rectangles) {
         _hideQuickMenu();
      },

      // Trigger the rendering of the attached menu or custom widgets
      onSelectionCompleted: (markers) {
         final isCollapsed = _controller?.selection.isCollapsed ?? true;

         // Don't render menu for selections that are collapsed (zero chars selected)
         if (!isCollapsed) {

            // Use your own logic for rendering and positioning the attached widget(s)
            _displayQuickMenuOnTextSelection(markers);
         }
      },
   );
}
```
  
Join on [discord](https://discord.gg/XpGygmXde4) to get advice and help or follow us on [YouTube Visual Coding](https://www.youtube.com/channel/UC2-5lfNbbErIds0Iuai8yfA) to learn more about the architecture of Visual Editor and other Flutter apps.